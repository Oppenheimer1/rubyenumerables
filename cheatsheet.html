<!DOCTYPE HTML PUBLIC "-//W3C//Ddiv HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.ddiv">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Ruby Enumerable Cheat Sheet</title>
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen">
  </head>
  <body>
   <h1>Ruby Enumerables</h1>
    <h6><a href="http://ruby-doc.org/core-2.1.0/Enumerable.html">Source</a></h6>
      <div class="tr">
        <div class="r1">Method</div>
        <div class="r1">Description</div>
        <div class="r1">Example</div>
      </div>
      <div class="tr">
        <div>#all?</div>
        <div>all? [{ |obj| block } ] → true or false <br>
          Passes each element of the collection to the given block. The method returns true if the block never returns false or nil. If the block is not given, Ruby adds an implicit block of { |obj| obj } which will cause all? to return true when none of the collection members are false or nil.
        </div>
        <div>%w[ant bear cat].all? { |word| word.length >= 3 } #=> true<br>
          %w[ant bear cat].all? { |word| word.length >= 4 } #=> false<br>
          [nil, true, 99].all?                              #=> false
        </div>
      </div>
      <div class="tr">
        <div>#any?</div>
        <div>any? [{ |obj| block }] → true or false <br>
          Passes each element of the collection to the given block. The method returns true if the block ever returns a value other than false or nil. If the block is not given, Ruby adds an implicit block of { |obj| obj } that will cause any? to return true if at least one of the collection members is not false or nil.
        </div>
        <div>%w[ant bear cat].any? { |word| word.length >= 3 } #=> true<br>
          %w[ant bear cat].any? { |word| word.length >= 4 } #=> true<br>
          [nil, true, 99].any?                              #=> true    
        </div>
      </div>
      <div class="tr">
        <div class="r5"></div>
        <div>chunk { |elt| ... } → an_enumerator <br>
          chunk(initial_state) { |elt, state| ... } → an_enumerator<br>
          Enumerates over the items, chunking them together based on the return value of the block.
          Consecutive elements which return the same block value are chunked together.
          For example, consecutive even numbers and odd numbers can be chunked as follows.
        </div>
        <div>[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5].chunk { |n|
          n.even?
          }.each { |even, ary|
          p [even, ary] }<br>
          #=> [false, [3, 1]]<br>
          #   [true, [4]]<br>
          #   [false, [1, 5, 9]]<br>
          #   [true, [2, 6]]<br>
          #   [false, [5, 3, 5]]
        </div>
      </div>
      <div class="tr">
        <div class="r6"></div>
        <div>This method is especially useful for sorted series of elements. The following example counts words for each initial letter.</div>
        <div>open("/usr/share/dict/words", "r:iso-8859-1") { |f|
          f.chunk { |line| line.ord }.each { |ch, lines| p [ch.chr, lines.length] } }<br>
          #=> ["\n", 1]<br>
          #   ["A", 1327]<br>
          #   ["B", 1372]<br>
          #   ["C", 1507]<br>
          #   ["D", 791]
          #   ...
        </div>
      </div>
      <div class="tr">
        <div class="r6"></div>
        <div>The following key values have special meaning:
          nil and :_separator specifies that the elements should be dropped.
          :_alone specifies that the element should be chunked by itself.
          Any other symbols that begin with an underscore will raise an error:
        </div>
        <div>items.chunk { |item| :_underscore }
          #=> RuntimeError: symbols beginning with an underscore are reserved
        </div>
      </div>
      <div class="tr">
        <div class="r6">#chunk</div>
        <div>nil and :_separator can be used to ignore some elements.
          For example, the sequence of hyphens in svn log can be eliminated as follows:
        </div>
        <div>sep = "-"*72 + "\n"
          IO.popen("svn log README") { |f|
          f.chunk { |line|
          line != sep || nil
          }.each { |_, lines|
          pp lines
          }
          }<br>
          #=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",<br>
          #    "\n",<br>
          #    "* README, README.ja: Update the portability section.\n",<br>
          #    "\n"]<br>
          #   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",<br>
          #    "\n",<br>
          #    "* README, README.ja: Add a note about default C flags.\n",<br>
          #    "\n"]
          #   ...
        </div>
      </div>
      <div class="tr">
        <div class="r6"></div>
        <div>Paragraphs separated by empty lines can be parsed as follows:</div>
        <div>File.foreach("README").chunk { |line|
          /\A\s*\z/ !~ line || nil
          }.each { |_, lines|
          pp lines
          }
        </div>
      </div>
      <div class="tr">
        <div class="r6"></div>
        <div>:_alone can be used to force items into their own chunk. For example, you can put lines that contain a URL by themselves, and chunk the rest of the 	  lines together, like this:
          If the block needs to maintain state over multiple elements, an initial_state argument can be used. If a non-nil value is given, a reference to it is passed as the 2nd argument of the block for the chunk method, so state-changes to it persist across block calls.
        </div>
        <div>pattern = /http/
          open(filename) { |f|
          f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
          pp lines
          }
          }
        </div>
      </div>
     <div class="tr">
        <div>#collect</div>
        <div>collect { |obj| block } → array <br>
          collect → an_enumerator<br>
          Returns a new array with the results of running block once for every element in enum.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>(1..4).map { |i| i*i }      #=> [1, 4, 9, 16]<br>
          (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
        </div>
      </div>
      <div class="tr">
        <div>#collect_concat</div>
        <div>collect_concat { |obj| block } → array <br>
          collect_concat → an_enumerator Returns a new array with the concatenated results of running block once for every element in enum.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>[1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]<br>
          [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]
        </div>
      </div>
      <div class="tr">
        <div>#count</div>
        <div>count → int <br>
          count(item) → int
          count { |obj| block } → int
          Returns the number of items in enum through enumeration. If an argument is given, the number of items in enum that are equal to item are counted. If a block is given, it counts the number of elements yielding a true value.
        </div>
        <div>ary = [1, 2, 4, 2]<br>
          ary.count               #=> 4<br>
          ary.count(2)            #=> 2<br>
          ary.count{ |x| x%2==0 } #=> 3
        </div>
      </div>
      <div class="tr">
        <div>#cycle</div>
        <div>cycle(n=nil) { |obj| block } → nil <br>
          cycle(n=nil) → an_enumerator<br>
          Calls block for each element of enum repeatedly n times or forever if none or nil is given. If a non-positive number is given or the collection is empty, does nothing. Returns nil if the loop has finished without getting interrupted.
          #cycle saves elements in an internal array so changes to enum after the first pass have no effect.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = ["a", "b", "c"]<br>
          a.cycle { |x| puts x }  # print, a, b, c, a, b, c,.. forever.<br>
          a.cycle(2) { |x| puts x }  # print, a, b, c, a, b, c.
        </div>
      </div>
      <div class="tr">
        <div>#detect</div>
        <div>detect(ifnone = nil) { |obj| block } → obj or nil <br>
          detect(ifnone = nil) → an_enumerator
          Passes each entry in enum to block. Returns the first for which block is not false. If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>(1..10).detect  { |i| i % 5 == 0 and i % 7 == 0 }   #=> nil<br>
          (1..100).detect { |i| i % 5 == 0 and i % 7 == 0 }   #=> 35
        </div>
      </div>
      <div class="tr">
        <div>#drop</div>
        <div>drop(n) → array
          Drops first n elements from enum, and returns rest elements in an array.
        </div>
        <div>a = [1, 2, 3, 4, 5, 0]<br>
          a.drop(3)             #=> [4, 5, 0]
        </div>
      </div>
     <div class="tr">
        <div>#drop_while</div>
        <div>drop_while { |arr| block } → array <br>
          drop_while → an_enumerator<br>
          Drops elements up to, but not including, the first element for which the block returns nil or false and returns an array containing the remaining elements.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = [1, 2, 3, 4, 5, 0]<br>
          a.drop_while { |i| i < 3 }   #=> [3, 4, 5, 0]
        </div>
      </div>
      <div class="tr">
        <div>#each_cons</div>
        <div>
          each_cons(n) { ... } → nil <br>
          each_cons(n) → an_enumerator<br>
          Iterates the given block for each array of consecutive 
          <n>
          elements. If no block is given, returns an enumerator.
          e.g.:
        </div>
        <div>(1..10).each_cons(3) { |a| p a }
          # outputs below<br>
          [1, 2, 3]<br>
          [2, 3, 4]<br>
          [3, 4, 5]<br>
          [4, 5, 6]<br>
          [5, 6, 7]<br>
          [6, 7, 8]<br>
          [7, 8, 9]<br>
          [8, 9, 10]
        </div>
      </div>
      <div class="tr">
        <div>#each_entry</div>
        <div>each_entry { |obj| block } → enum <br>
          each_entry → an_enumerator
          Calls block once for each element in self, passing that element as a parameter, converting multiple values from yield to an array.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>class Foo
          include Enumerable
          def each
          yield 1
          yield 1, 2
          yield
          end
          end
          Foo.new.each_entry{ |o| p o }<br>
          produces: 1<br>
          [1, 2]<br>
          nil
        </div>
      </div>
     <div class="tr">
        <div>#each_slice</div>
        <div>
          each_slice(n) { ... } → nil <br>
          each_slice(n) → an_enumerator
          Iterates the given block for each slice of 
          <n>
          elements. If no block is given, returns an enumerator.
        </div>
        <div>(1..10).each_slice(3) { |a| p a }
          # outputs below<br>
          [1, 2, 3]<br>
          [4, 5, 6]<br>
          [7, 8, 9]<br>
          [10]
        </div>
      </div>
      <div class="tr">
        <div>#each_with_index</div>
        <div>each_with_index(*args) { |obj, i| block } → enum <br>
          each_with_index(*args) → an_enumerator<br>
          Calls block with two arguments, the item and its index, for each item in enum. Given arguments are passed through to each().
          If no block is given, an enumerator is returned instead.
        </div>
        <div>hash = Hash.new
          %w(cat dog wombat).each_with_index { |item, index|
          hash[item] = index
          }
          hash   #=> {"cat"=>0, "dog"=>1, "wombat"=>2}
        </div>
      </div>
      <div class="tr">
        <div>#each_with_object</div>
        <div>each_with_object(obj) { |(*args), memo_obj| ... } → obj <br>
          each_with_object(obj) → an_enumerator
          Iterates the given block for each element with an arbitrary object given, and returns the initially given object.
          If no block is given, returns an enumerator.
        </div>
        <div>evens = (1..10).each_with_object([]) { |i, a| a << i*2 }<br>
          #=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
        </div>
      </div>
      <div class="tr">
        <div>#entries</div>
        <div>entries(*args) → array <br>
          Returns an array containing the items in enum.
        </div>
        <div>(1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]<br>
          { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]<br>
          require 'prime'<br>
          Prime.entries 10                  #=> [2, 3, 5, 7]
        </div>
      </div>
      <div class="tr">
        <div>#find</div>
        <div>find(ifnone = nil) { |obj| block } → obj or nil <br>
          find(ifnone = nil) → an_enumerator
          Passes each entry in enum to block. Returns the first for which block is not false. If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>(1..10).detect  { |i| i % 5 == 0 and i % 7 == 0 }   #=> nil<br>
          (1..100).detect { |i| i % 5 == 0 and i % 7 == 0 }   #=> 35
        </div>
      </div>
      <div class="tr">
        <div>#find_all</div>
        <div>find_all { |obj| block } → array <br>
          find_all → an_enumerator
          Returns an array containing all elements of enum for which the given block returns a true value.
          If no block is given, an Enumerator is returned instead.
        </div>
        <div>(1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]<br>
          [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]
        </div>
      </div>
      <div class="tr">
        <div>#find_index</div>
        <div>find_index(value) → int or nil <br>
          find_index { |obj| block } → int or nil
          find_index → an_enumerator
          Compares each entry in enum with value or passes to block. Returns the index for the first for which the evaluated value is non-false. If no object matches, returns nil If neither block nor argument is given, an enumerator is returned instead.
        </div>
        <div>(1..10).find_index  { |i| i % 5 == 0 and i % 7 == 0 }  #=> nil<br>
          (1..100).find_index { |i| i % 5 == 0 and i % 7 == 0 }  #=> 34<br>
          (1..100).find_index(50) #=> 49
        </div>
      </div>
      <div class="tr">
        <div>#first</div>
        <div>first → obj or nil <br>
          first(n) → an_array
          Returns the first element, or the first n elements, of the enumerable. If the enumerable is empty, the first form returns nil, and the second form returns an empty array.
        </div>
        <div>%w[foo bar baz].first     #=> "foo"<br>
          %w[foo bar baz].first(2)  #=> ["foo", "bar"]<br>
          %w[foo bar baz].first(10) #=> ["foo", "bar", "baz"]<br>
          [].first                  #=> nil
        </div>
      </div>
       <div class="tr">
        <div>#flat_map</div>
        <div>flat_map { |obj| block } → array <br>
          flat_map → an_enumerator<br>
          Returns a new array with the concatenated results of running block once for every element in enum.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>[1, 2, 3, 4].flat_map { |e| [e, -e] } #=> [1, -1, 2, -2, 3, -3, 4, -4]<br>
          [[1, 2], [3, 4]].flat_map { |e| e + [100] } #=> [1, 2, 100, 3, 4, 100]
        </div>
      </div>
      <div class="tr">
        <div>#grep</div>
        <div>grep(pattern) → array <br>
          grep(pattern) { |obj| block } → array<br>
          Returns an array of every element in enum for which Pattern === element. If the optional block is supplied, each matching element is passed to it, and the block’s result is stored in the output array.
        </div>
        <div>(1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]<br>
          c = IO.constants<br>
          c.grep(/SEEK/)         #=> [:SEEK_SET, :SEEK_CUR, :SEEK_END]<br>
          res = c.grep(/SEEK/) { |v| IO.const_get(v) }<br>
          res                    #=> [0, 1, 2]
        </div>
      </div>
      <div class="tr">
        <div>#group_by</div>
        <div>group_by { |obj| block } → a_hash<br>
          group_by → an_enumerator<br>
          Groups the collection by result of the block. Returns a hash where the keys are the evaluated result from the block and the values are arrays of elements in the collection that correspond to the key.
          If no block is given an enumerator is returned.
        </div>
        <div>(1..6).group_by { |i| i%3 }   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}</div>
      </div>
      <div class="tr">
        <div>#include?</div>
        <div>include?(obj) → true or false <br>
          Returns true if any member of enum equals obj. Equality is tested using ==.
        </div>
        <div>IO.constants.include? :SEEK_SET          #=> true<br>
          IO.constants.include? :SEEK_NO_FURTHER   #=> false
        </div>
      </div>
      <div class="tr">
        <div>#inject</div>
        <div>inject(initial, sym) → obj <br>
          inject(sym) → obj<br>
          inject(initial) { |memo, obj| block } → obj<br>
          inject { |memo, obj| block } → obj<br>
          Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.
          If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method.
          If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.
        </div>
        <div># Sum some numbers<br>
          (5..10).reduce(:+)                             #=> 45<br>
          # Same using a block and inject<br>
          (5..10).inject { |sum, n| sum + n }            #=> 45<br>
          # Multiply some numbers<br>
          (5..10).reduce(1, :*)                          #=> 151200<br>
          # Same using a block<br>
          (5..10).inject(1) { |product, n| product * n } #=> 151200v
          # find the longest word<br>
          longest = %w{ cat sheep bear }.inject do |memo, word|
          memo.length > word.length ? memo : word
          end<br>
          longest                                        #=> "sheep"
        </div>
      </div>
      <div class="tr">
        <div>#lazy</div>
        <div>lazy → lazy_enumerator<br>
          Returns a lazy enumerator, whose methods map/collect, flat_map/collect_concat, select/find_all, reject, grep, zip, take, #take_while, drop, and #drop_while enumerate values only on an as-needed basis. However, if a block is given to zip, values are enumerated immediately.
          Example¶ ↑
          The following program finds pythagorean triples:
        </div>
        <div>def pythagorean_triples
          (1..Float::INFINITY).lazy.flat_map {|z|
          (1..z).flat_map {|x|
          (x..z).select {|y|
          x**2 + y**2 == z**2
          }.map {|y|
          [x, y, z]
          }
          }
          }
          end
          # show first ten pythagorean triples<br>
          p pythagorean_triples.take(10).force # take is lazy, so force is needed<br>
          p pythagorean_triples.first(10)      # first is eager<br>	
          # show pythagorean triples less than 100<br>
          p pythagorean_triples.take_while { |*, z| z < 100 }.force
        </div>
      </div>
      <div class="tr">
        <div>#map</div>
        <div>map { |obj| block } → array <br>
          map → an_enumerator<br>
          Returns a new array with the results of running block once for every element in enum.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>(1..4).map { |i| i*i }      #=> [1, 4, 9, 16]<br>
          (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]
        </div>
      </div>
      <div class="tr">
        <div>#max</div>
        <div>max → obj <br>
          max { |a, b| block } → obj<br>
          Returns the object in enum with the maximum value. The first form assumes all objects implement Comparable; the second uses the block to return a <=> b.
        </div>
        <div>a = %w(albatross dog horse)<br>
          a.max                                   #=> "horse"<br>
          a.max { |a, b| a.length <=> b.length }  #=> "albatross"
        </div>
      </div>
      <div class="tr">
        <div>#max_by</div>
        <div>max_by { |obj| block } → obj <br>
          max_by → an_enumerator<br>
          Returns the object in enum that gives the maximum value from the given block.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = %w(albatross dog horse)
          a.max_by { |x| x.length }   #=> "albatross"
        </div>
      </div>
      <div class="tr">
        <div>#member?</div>
        <div>member?(obj) → true or false<br>
          Returns true if any member of enum equals obj. Equality is tested using ==.
        </div>
        <div>IO.constants.include? :SEEK_SET          #=> true<br>
          IO.constants.include? :SEEK_NO_FURTHER   #=> false
        </div>
      </div>
      <div class="tr">
        <div>#min</div>
        <div>min → obj <br>
          min { |a, b| block } → obj<br>
          Returns the object in enum with the minimum value. The first form assumes all objects implement Comparable; the second uses the block to return a <=> b.
        </div>
        <div>a = %w(albatross dog horse)<br>
          a.min                                   #=> "albatross"<br>
          a.min { |a, b| a.length <=> b.length }  #=> "dog"
        </div>
      </div>
      <div class="tr">
        <div>#min_by</div>
        <div>min_by { |obj| block } → obj <br>
          min_by → an_enumerator<br>
          Returns the object in enum that gives the minimum value from the given block.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = %w(albatross dog horse)<br>
          a.min_by { |x| x.length }   #=> "dog"
        </div>
      </div>
      <div class="tr">
        <div>#minmax</div>
        <div>minmax → [min, max] <br>
          minmax { |a, b| block } → [min, max]<br>
          Returns two elements array which contains the minimum and the maximum value in the enumerable. The first form assumes all objects implement Comparable; the second uses the block to return a <=> b.
        </div>
        <div>a = %w(albatross dog horse)<br>
          a.minmax                                  #=> ["albatross", "horse"]<br>
          a.minmax { |a, b| a.length <=> b.length } #=> ["dog", "albatross"]
        </div>
      </div>
      <div class="tr">
        <div>#minmax_by</div>
        <div>minmax_by { |obj| block } → [min, max] <br>
          minmax_by → an_enumerator<br>
          Returns a two element array containing the objects in enum that correspond to the minimum and maximum values respectively from the given block.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = %w(albatross dog horse)<br>
          a.minmax_by { |x| x.length }   #=> ["dog", "albatross"]
        </div>
      </div>
      <div class="tr">
        <div>#none?</div>
        <div>none? [{ |obj| block }] → true or false <br>
          Passes each element of the collection to the given block. The method returns true if the block never returns true for all elements. If the block is not given, none? will return true only if none of the collection members is true.
        </div>
        <div>%w{ant bear cat}.none? { |word| word.length == 5 } #=> true<br>
          %w{ant bear cat}.none? { |word| word.length >= 4 } #=> false<br>
          [].none?                                           #=> true<br>
          [nil].none?                                        #=> true<br>
          [nil, false].none?                                 #=> true
        </div>
      </div>
      <div class="tr">
        <div>#one?</div>
        <div>one? [{ |obj| block }] → true or false <br>
          Passes each element of the collection to the given block. The method returns true if the block returns true exactly once. If the block is not given, one? will return true only if exactly one of the collection members is true.
        </div>
        <div>%w{ant bear cat}.one? { |word| word.length == 4 }  #=> true<br>
          %w{ant bear cat}.one? { |word| word.length > 4 }   #=> false<br>
          %w{ant bear cat}.one? { |word| word.length < 4 }   #=> false<br>
          [ nil, true, 99 ].one?                             #=> false<br>
          [ nil, true, false ].one?                          #=> true
        </div>
      </div>
      <div class="tr">
        <div>#partition</div>
        <div>partition { |obj| block } → [ true_array, false_array ] <br>
          partition → an_enumerator<br>
          Returns two arrays, the first containing the elements of enum for which the block evaluates to true, the second containing the rest.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>(1..6).partition { |v| v.even? }  #=> [[2, 4, 6], [1, 3, 5]]</div>
      </div>
      <div class="tr">
        <div>#reduce</div>
        <div>reduce(initial, sym) → obj<br>
          reduce(sym) → obj<br>
          reduce(initial) { |memo, obj| block } → obj<br>
          reduce { |memo, obj| block } → obj<br>
          Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator.
          If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method.
          If you do not explicitly specify an initial value for memo, then the first element of collection is used as the initial value of memo.
        </div>
        <div># Sum some numbers<br>
          (5..10).reduce(:+)                             #=> 45<br>
          # Same using a block and inject<br>
          (5..10).inject { |sum, n| sum + n }            #=> 45<br>
          # Multiply some numbers<br>
          (5..10).reduce(1, :*)                          #=> 151200<br>
          # Same using a block<br>
          (5..10).inject(1) { |product, n| product * n } #=> 151200<br>
          # find the longest word<br>
          longest = %w{ cat sheep bear }.inject do |memo, word|
          memo.length > word.length ? memo : word
          end<br>
          longest                                        #=> "sheep"
        </div>
      </div>
      <div class="tr">
        <div>#reject</div>
        <div>reject { |obj| block } → array <br>
          reject → an_enumerator Returns an array for all elements of enum for which the given block returns false.
          If no block is given, an Enumerator is returned instead.
        </div>
        <div>(1..10).reject { |i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]<br>
          [1, 2, 3, 4, 5].reject { |num| num.even? } #=> [1, 3, 5]
        </div>
      </div>
      <div class="tr">
        <div>#reverse_each</div>
        <div>reverse_each(*args) { |item| block } → enum <br>
          reverse_each(*args) → an_enumerator<br>
          Builds a temporary array and traverses that array in reverse order.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>  (1..3).reverse_each { |v| p v }<br>
          produces:<br>
          3
          2
          1
        </div>
      </div>
      <div class="tr">
        <div>#select</div>
        <div>select { |obj| block } → array <br>
          select → an_enumerator Returns an array containing all elements of enum for which the given block returns a true value.
          If no block is given, an Enumerator is returned instead.
        </div>
        <div>(1..10).find_all { |i|  i % 3 == 0 }   #=> [3, 6, 9]<br>
          [1,2,3,4,5].select { |num|  num.even?  }   #=> [2, 4]
        </div>
      </div>
      <div class="tr">
        <div class="r5"></div>
        <div>slice_before(pattern) → an_enumerator <br>
          slice_before { |elt| bool } → an_enumerator<br>
          slice_before(initial_state) { |elt, state| bool } → an_enumerator<br>
          Creates an enumerator for each chunked elements. The beginnings of chunks are defined by pattern and the block.
          If pattern === elt returns true or the block returns true for the element, the element is beginning of a chunk.
          The === and block is called from the first element to the last element of enum. The result for the first element is ignored.
          The result enumerator yields the chunked elements as an array. So each method can be called as follows:
        </div>
        <div>enum.slice_before(pattern).each { |ary| ... }<br>
          enum.slice_before { |elt| bool }.each { |ary| ... }<br>
          enum.slice_before(initial_state) { |elt, state| bool }.each { |ary| ... }
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>Other methods of the Enumerator class and Enumerable module, such as map, etc., are also usable.
          For example, iteration over ChangeLog entries can be implemented as follows:
        </div>
        <div># iterate over ChangeLog entries.<br>
          open("ChangeLog") { |f|
          f.slice_before(/\A\S/).each { |e| pp e }
          }<br>
          # same as above.  block is used instead of pattern argument.<br>
          open("ChangeLog") { |f|
          f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
          }
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>“svn proplist -R” produces multiline output for each file. They can be chunked as follows:</div>
        <div>IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) { |f|
          f.lines.slice_before(/\AProp/).each { |lines| p lines }
          }<br>
          #=> ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]<br>
          #   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]<br>
          #   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]<br>
          #   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
          #   ...
        </div>
      </div>
      <div class="tr"><div class="r6">#slice_before</div>
        <div>If the block needs to maintain state over multiple elements, local variables can be used. For example, three or more consecutive increasing numbers can be squashed as follows:</div>
        <div>a = [0, 2, 3, 4, 6, 7, 9]
          prev = a[0]
          p a.slice_before { |e|
          prev, prev2 = e, prev
          prev2 + 1 != e
          }.map { |es|
          es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"
          }.join(",")<br>
          #=> "0,2-4,6,7,9"
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>However local variables are not appropriate to maintain state if the result enumerator is used twice or more. In such a case, the last state of     the 1st each is used in the 2nd each. The initial_state argument can be used to avoid this problem. If non-nil value is given as initial_state, it is duplicated for each each method invocation of the enumerator. The duplicated object is passed to 2nd argument of the block for slice_before method.</div>
        <div># Word wrapping.  This assumes all characters have same width.<br>
          def wordwrap(words, maxwidth)<br>
          # if cols is a local variable, 2nd "each" may start with non-zero cols.<br>
          words.slice_before(cols: 0) { |w, h|
          h[:cols] += 1 if h[:cols] != 0
          h[:cols] += w.length
          if maxwidth < h[:cols]
          h[:cols] = w.length
          true
          else
          false
          end
          }
          end<br>
          text = (1..20).to_a.join(" ")<br>
          enum = wordwrap(text.split(/\s+/), 10)<br>
          puts "-"*10<br>
          enum.each { |ws| puts ws.join(" ") }<br>
          puts "-"*10<br>
          #=> ----------
          #   1 2 3 4 5
          #   6 7 8 9 10
          #   11 12 13
          #   14 15 16
          #   17 18 19
          #   20
          #   ----------
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>mbox contains series of mails which start with Unix From line. So each mail can be extracted by slice before Unix From line.</div>
        <div># parse mbox<br>
          open("mbox") { |f|
          f.slice_before { |line|
          line.start_with? "From "
          }.each { |mail|
          unix_from = mail.shift
          i = mail.index("\n")
          header = mail[0...i]
          body = mail[(i+1)..-1]
          body.pop if body.last == "\n"
          fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
          p unix_from
          pp fields
          pp body
          }
          }<br>
          # split mails in mbox (slice before Unix From line after an empty line)<br>
          open("mbox") { |f|
          f.slice_before(emp: true) { |line, h|
          prevemp = h[:emp]
          h[:emp] = line == "\n"
          prevemp && line.start_with?("From ")
          }.each { |mail|
          mail.pop if mail.last == "\n"
          pp mail
          }
          }
        </div>
      </div>
      <div class="tr">
        <div>#sort</div>
        <div>sort → array <br>
          sort { |a, b| block } → array
          Returns an array containing the items in enum sorted, either according to their own <=> method, or by using the results of the supplied block. The block should return -1, 0, or +1 depending on the comparison between a and b. As of Ruby 1.8, the method Enumerable#sort_by implements a built-in Schwartzian Transform, useful when key computation or comparison is expensive.
        </div>
        <div>%w(rhea kea flea).sort          #=> ["flea", "kea", "rhea"]<br>
          (1..10).sort { |a, b| b <=> a }  #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
        </div>
      </div>
      <div class="tr">
        <div class="r5"></div>
        <div>sort_by { |obj| block } → array <br>
          sort_by → an_enumerator<br>
          Sorts enum using a set of keys generated by mapping the values in enum through the given block.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>%w{apple pear fig}.sort_by { |word| word.length}
          #=> ["fig", "pear", "apple"]
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>The current implementation of sort_by generates an array of tuples containing the original collection element and the mapped value. This makes sort_by fairly expensive when the keysets are simple.</div>
        <div>require 'benchmark'
          a = (1..100000).map { rand(100000) }
          Benchmark.bm(10) do |b|
          b.report("Sort")    { a.sort }
          b.report("Sort by") { a.sort_by { |a| a } }
          end<br>
          produces:<br>
          user     system      total        real
          Sort        0.180000   0.000000   0.180000 (  0.175469)
          Sort by     1.980000   0.040000   2.020000 (  2.013586)
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>However, consider the case where comparing the keys is a non-trivial operation. The following code sorts some files on modification time using the basic sort method.</div>
        <div>files = Dir["*"]
          sorted = files.sort { |a, b| File.new(a).mtime <=> File.new(b).mtime }<br>
          sorted   #=> ["mon", "tues", "wed", "thurs"]
        </div>
      </div>
      <div class="tr"><div class="r6">#sort_by</div>
        <div>This sort is inefficient: it generates two new File objects during every comparison. A slightly better technique is to use the Kernel#test method to generate the modification times directly.</div>
        <div>files = Dir["*"]
          sorted = files.sort { |a, b|
          test(?M, a) <=> test(?M, b)
          }
          sorted   #=> ["mon", "tues", "wed", "thurs"]
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>This still generates many unnecessary Time objects. A more efficient technique is to cache the sort keys (modification times in this case) before the sort. Perl users often call this approach a Schwartzian Transform, after Randal Schwartz. We construct a temporary array, where each element is an array containing our sort key along with the filename. We sort this array, and then extract the filename from the result.</div>
        <div>sorted = Dir["*"].collect { |f|
          [test(?M, f), f]
          }.sort.collect { |f| f[1] }
          sorted   #=> ["mon", "tues", "wed", "thurs"]
        </div>
      </div>
      <div class="tr"><div class="r6"></div>
        <div>This is exactly what sort_by does internally.</div>
        <div>sorted = Dir["*"].sort_by { |f| test(?M, f) }<br>
          sorted   #=> ["mon", "tues", "wed", "thurs"]
        </div>
      </div>
      <div class="tr">
        <div>#take</div>
        <div>take(n) → array <br>
          Returns first n elements from enum.
        </div>
        <div>a = [1, 2, 3, 4, 5, 0]<br>
          a.take(3)             #=> [1, 2, 3]
        </div>
      </div>
      <div class="tr">
        <div>#take_while</div>
        <div>take_while { |arr| block } → array <br>
          take_while → an_enumerator<br>
          Passes elements to the block until the block returns nil or false, then stops iterating and returns an array of all prior elements.
          If no block is given, an enumerator is returned instead.
        </div>
        <div>a = [1, 2, 3, 4, 5, 0]<br>
          a.take_while { |i| i < 3 }   #=> [1, 2]
        </div>
      </div>
      <div class="tr">
        <div>#to_a</div>
        <div>to_a(*args) → array <br>
          Returns an array containing the items in enum.
        </div>
        <div>(1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]<br>
          { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]<br>
          require 'prime'<br>
          Prime.entries 10                  #=> [2, 3, 5, 7]
        </div>
      </div>
      <div class="tr">
        <div>#to_h</div>
        <div>to_h(*args) → hash <br>
          Returns the result of interpreting enum as a list of [key, value] pairs.
        </div>
        <div>%[hello world].each_with_index.to_h<br>
          # => {:hello => 0, :world => 1}
        </div>
      </div>
      <div class="tr">
        <div>#zip</div>
        <div>zip(arg, ...) → an_array_of_array<br>
          zip(arg, ...) { |arr| block } → nil<br>
          Takes one element from enum and merges corresponding elements from each args. This generates a sequence of n-element arrays, where n is one more than the count of arguments. The length of the resulting sequence will be enum#size. If the size of any argument is less than enum#size, nil values are supplied. If a block is given, it is invoked for each output array, otherwise an array of arrays is returned.
        </div>
        <div>a = [ 4, 5, 6 ]<br>
          b = [ 7, 8, 9 ]<br>
          [1, 2, 3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]<br>
          [1, 2].zip(a, b)         #=> [[1, 4, 7], [2, 5, 8]]<br>
          a.zip([1, 2], [8])       #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]<br>
        </div>
      </div>
    <body>
  </body>
</html>